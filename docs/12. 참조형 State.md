## 참조형 State 다루기 (배열과 객체)

주사위 게임에 '총점'과 '기록' 기능을 추가하면서, 배열이나 객체 같은 **참조형(Reference Type) State**를 다룰 때 반드시 알아야 할 중요한 원칙에 대해 살펴보겠습니다.

---

### **1. 숫자형 State: 간단한 경우**

먼저 '총점' 기능입니다. 숫자형(`number`) State는 직관적으로 다룰 수 있습니다. 이전 `sum` 값에 새로운 주사위 눈(`nextNum`)을 더한 값을 `setSum` 함수에 넘겨주기만 하면 됩니다.

```jsx
const [sum, setSum] = useState(0);

const handleRollClick = () => {
  const nextNum = random(6);
  // ...
  setSum(sum + nextNum); // 이전 값 + 새 값 = 새로운 숫자 값
};
```

React는 `sum`의 값이 바뀐 것을 명확히 인지하고 화면을 다시 렌더링합니다. 하지만 배열이나 객체는 조금 다릅니다.

---

### **2. 배열 State: 흔한 실수와 그 이유**

이제 주사위 눈을 순서대로 기록하는 `gameHistory` State를 추가해 보겠습니다. 배열이므로, 가장 먼저 떠오르는 방법은 `push` 메서드를 사용하는 것입니다.

```jsx
// ❌ 잘못된 코드 (하지만 처음에는 동작하는 것처럼 보임)
const [gameHistory, setGameHistory] = useState([]);

const handleRollClick = () => {
  const nextNum = random(6);
  // ...
  gameHistory.push(nextNum); // 1. 기존 배열에 새로운 값을 추가
  setGameHistory(gameHistory); // 2. 바뀐 배열로 state를 업데이트?
};
```

이 코드는 다른 State(`num`이나 `sum`)가 함께 변경될 때는 마치 정상적으로 작동하는 것처럼 보입니다. 하지만 `setNum`과 `setSum`을 주석 처리하고 '던지기' 버튼을 눌러보면, `gameHistory` 배열에 값은 추가되지만 화면의 '기록'은 전혀 업데이트되지 않는 것을 볼 수 있습니다.

#### **왜 변화를 감지하지 못할까? React와 불변성(Immutability)**

이 문제의 원인은 JavaScript의 **참조형** 데이터 타입의 특징과, React가 **불변성**을 기반으로 변화를 감지하는 방식에 있습니다.

- **참조형의 특징**: `gameHistory`라는 변수는 배열 데이터 자체를 담고 있는 것이 아니라, 데이터가 저장된 **메모리의 주소**(참조)를 가리키고 있습니다.
- **`push` 메서드의 문제**: `gameHistory.push()`는 기존 배열의 내용을 직접 수정할 뿐, 메모리 주소 자체를 바꾸지는 않습니다.
- **React의 변화 감지**: React는 State가 변경되었는지 판단할 때, **State 변수가 가리키는 메모리 주소가 바뀌었는지**를 비교합니다. `push`를 사용하면 주소값이 그대로이기 때문에, React는 "어? 바뀐 게 없네?"라고 판단하고 화면을 다시 렌더링하지 않는 것입니다.

이것은 마치 보물상자(`배열 데이터`)에 보물(`nextNum`)을 몰래 더 넣어도, 보물상자를 가리키는 보물지도(`gameHistory` 변수) 자체는 바뀌지 않는 것과 같은 원리입니다. React는 보물상자 안을 일일이 확인하는 대신, 보물지도 자체가 새것으로 바뀌었는지만 확인하여 효율적으로 동작합니다.

---

### **3. 올바른 해결책: 새로운 값으로 교체하기**

> **참조형 State의 황금률: 직접 수정하지 말고, 항상 새로운 복사본을 만들어 교체하라.**

배열이나 객체 State를 업데이트할 때는, 원본을 직접 수정하는 대신 **새로운 배열이나 객체를 만들어** Setter 함수에 전달해야 합니다. 이때 가장 간단하고 효과적인 방법이 바로 **스프레드 문법(`...`)** 입니다.

```jsx
// ✅ 올바른 코드
const handleRollClick = () => {
  const nextNum = random(6);
  // ...

  // 1. 기존 gameHistory 배열의 모든 요소를 복사해 새로운 배열을 만들고,
  // 2. 그 뒤에 nextNum을 추가한 '완전히 새로운 배열'을 생성한다.
  setGameHistory([...gameHistory, nextNum]);
};
```

`[...gameHistory, nextNum]` 코드는 기존 배열의 주소와는 다른, 완전히 새로운 배열을 만듭니다. React는 새로운 주소값을 감지하고 State가 변경되었다고 판단하여 화면을 성공적으로 다시 렌더링합니다.

이 **불변성을 지키는 원칙**은 React 개발에서 매우 중요하므로, 배열이나 객체 State를 다룰 때는 `push` 대신 **스프레드 문법**이나 `map`, `filter` 같은 새로운 배열을 반환하는 메서드를 사용해야 한다는 점을 꼭 기억하세요.
