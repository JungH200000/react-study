## React 데이터 렌더링 준비: mock 데이터 활용하기

실제 서버와 통신하기에 앞서, 화면에 보여줄 데이터가 있다고 가정하고 UI를 먼저 개발하는 것은 매우 효율적인 방법입니다. 이때 사용하는 것이 바로 **'mock 데이터'** 입니다.

### 1\. `mock.json` 분석하기 📝

**mock 데이터**란 '흉내 내다(mock)'라는 뜻처럼, 실제 API를 통해 받아올 데이터의 형태를 흉내 낸 가짜 데이터입니다. 우리는 `mock.json` 파일을 통해 앞으로 서버에서 받아올 리뷰 데이터의 구조를 미리 정의하고 사용해 보겠습니다.

`mock.json` 파일의 각 리뷰 데이터는 다음과 같은 정보(key-value)로 이루어져 있습니다.

- **`id`**: 데이터를 구분하는 고유한 값입니다. 나중에 데이터를 수정하거나 삭제할 때 유용하게 사용됩니다.
- **`title`**: 영화 제목
- **`imgUrl`**: 영화 포스터 이미지 주소
- **`rating`**: 별점 (1\~5)
- **`content`**: 리뷰 내용
- **`createdAt`**: 리뷰 생성 날짜

---

### 2\. 컴포넌트 구조 잡기 📦

이제 이 mock 데이터를 화면에 목록 형태로 보여줄 `ReviewList` 컴포넌트를 만들어 보겠습니다.

#### `ReviewList` 컴포넌트 생성

먼저, 컴포넌트 파일들을 체계적으로 관리하기 위해 `src` 폴더 아래에 `components`라는 폴더를 만들고, 그 안에 `ReviewList.jsx` 파일을 생성합니다.

**`src/components/ReviewList.jsx`**

```jsx
function ReviewList({ items }) {
  // props로 받은 items를 console에 출력해봅니다.
  console.log(items);

  return <ul></ul>;
}

export default ReviewList;
```

#### `App` 컴포넌트에서 데이터 전달하기

`App.jsx`에서 `mock.json` 파일을 불러온 뒤, `ReviewList` 컴포넌트에 `items`라는 이름의 prop으로 전달합니다.

**`src/App.jsx`**

```jsx
import ReviewList from './components/ReviewList';
import items from './mock.json'; // 1. mock 데이터를 불러옵니다.

function App() {
  return (
    <div>
      {/* 2. items prop으로 데이터를 전달합니다. */}
      <ReviewList items={items} />
    </div>
  );
}

export default App;
```

_`StrictMode`나 `createRoot` 같은 코드가 있는 `main.jsx`는 수정할 필요가 없습니다._

---

### 3\. 데이터 전달 확인하기 🔍

이제 프로젝트를 실행하고 브라우저의 개발자 도구(F12)에서 Console 탭을 확인해 봅시다.

`console.log(items)` 코드 덕분에 `App` 컴포넌트로부터 `items` prop을 잘 받았는지 확인할 수 있습니다.

**처음 콘솔에 찍히는 모습:**
`[object Object]`가 여러 개 담긴 배열 형태로 나타납니다. 이는 객체 데이터가 배열 안에 잘 들어있다는 의미입니다.

**배열을 펼쳤을 때의 모습:**
왼쪽의 화살표를 클릭하여 배열을 펼쳐보면, `mock.json` 파일의 내용과 동일한 43개의 리뷰 객체 데이터가 들어있는 것을 눈으로 직접 확인할 수 있습니다.

데이터가 컴포넌트까지 성공적으로 전달된 것을 확인했으니, 이제 다음 단계에서 이 데이터를 활용해 실제 화면을 그려볼 준비가 모두 끝났습니다\!

---

### 4\. 왜 '[object Object]' 일까요? 🏷️

`[object Object]`라고 보이는 것은 JavaScript 객체(Object)를 문자열로 변환하려고 할 때 나타나는 **기본 '이름표'** 같은 것입니다.

JavaScript의 모든 객체는 자기 자신을 소개하는 `toString()`이라는 기본 기능을 가지고 있습니다. 우리가 객체를 `console.log()`로 출력하면, 브라우저 콘솔은 그 객체의 내용을 보여주기 전에 먼저 이 `toString()` 기능을 호출해서 간단한 '소개 문구'를 표시합니다.

일반적인 객체(`{...}`)의 `toString()` 기능은 그냥 `"[object Object]"` 라는 글자를 반환하도록 약속되어 있습니다.

#### 신분증으로 비유해 볼게요

- **객체 데이터**: 이름, 나이, 직업 등 수많은 정보를 가진 '사람'과 같습니다.
- **`[object Object]`**: 그 사람의 모든 정보를 보여주기 전에, 일단 "이 사람은 **[분류: 사람]** 입니다" 라고 알려주는 **신분증**과 같습니다.

브라우저 콘솔은 똑똑해서, 먼저 이 간단한 신분증(`[object Object]`)을 보여주고, 우리가 궁금해하면(왼쪽 화살표를 클릭하면) 비로소 그 사람의 상세 정보(객체의 속성들)를 자세히 보여주는 것입니다.

---

### `[object Object]` 문법 파헤치기

이 표기법은 `[object 타입]` 이라는 정해진 형식을 따릅니다.

- **`[object ...]`**: "이것은 객체 타입의 데이터입니다"라는 의미의 접두사입니다.
- **`... Object]`**: 데이터의 구체적인 '타입'을 알려줍니다.

다른 데이터 타입들도 내부적으로는 이와 비슷한 이름표를 가지고 있습니다.

> `Object.prototype.toString.call([])` => `"[object Array]"` (이것은 배열입니다)
> `Object.prototype.toString.call(new Date())` => `"[object Date]"` (이것은 날짜입니다)
> `Object.prototype.toString.call("hello")` => `"[object String]"` (이것은 문자열입니다)

결론적으로 `[object Object]`는 **"이 데이터는 객체(Object) 타입의 객체(object)입니다"** 라고 알려주는 JavaScript의 공식적인 자기소개 방식인 셈입니다.
