## React Side Effect 처리하기 (useEffect Hook)

React 컴포넌트의 주된 임무는 JSX를 반환하여 화면을 그리는 것입니다. 하지만 때로는 컴포넌트가 화면을 그리는 것 외에 **추가적인 작업**을 해야 할 때가 있습니다.

- 서버에 데이터를 요청하고 응답받기 (API 호출)
- 수동으로 DOM 조작하기 (예: 특정 요소에 포커스 주기)
- 타이머 설정하기 (`setInterval`)

이처럼 렌더링 결과에 직접적인 영향을 주지 않는 모든 부가적인 작업을 **Side Effect(부수 효과)** 라고 부릅니다. React에서는 이러한 Side Effect를 깔끔하게 처리하기 위해 **`useEffect`** 라는 특별한 도구(Hook)를 제공합니다.

---

### `useEffect`란 무엇일까요? 🤖

`useEffect`를 스마트홈 비서라고 상상해 보세요. 우리는 비서에게 두 가지를 알려줘야 합니다.

1.  **"무엇을 할지" (콜백 함수)**: "온라인 쇼핑몰에서 물건을 주문해 줘." (`handleLoad()` 함수 실행)
2.  **"언제 할지" (의존성 배열, Dependency Array)**: "내가 '주문해'라고 말할 때만." (`order` state가 바뀔 때)

`useEffect`는 이 두 가지 정보를 받아, 렌더링이 완료된 후 정해진 '시점'에 '할 일'을 실행해 줍니다.

---

## 페이지 로딩 시 자동으로 데이터 가져오기

이전에는 '불러오기' 버튼을 클릭해야 데이터를 가져왔지만, 이제는 `useEffect`를 사용해 페이지가 처음 열릴 때 자동으로 데이터를 불러오도록 만들어 보겠습니다.

### 무한 루프의 함정

만약 컴포넌트 함수 안에서 아무런 장치 없이 데이터 로딩 함수를 바로 호출하면 어떻게 될까요?

```jsx
// ⚠️ 잘못된 예시입니다.
function App() {
  const [items, setItems] = useState([]);

  const handleLoad = async () => {
    const { reviews } = await getReviews();
    setItems(reviews); // 2. state 변경 -> 리렌더링 발생
  };

  handleLoad(); // 1. 렌더링 시 함수 호출 -> API 요청

  return (
    <>
      <div>
        // ...
        <ReviewList items={items} onDelete={handleDelete} />
        // 3. 리렌더링 -> 1번으로 돌아감 (무한 반복)
      </div>
    </>
  );
}
```

1.  컴포넌트가 렌더링되면서 `handleLoad()`가 호출됩니다.
2.  `handleLoad()` 함수는 데이터를 받아와 `setItems`로 state를 변경합니다.
3.  state가 변경되었으므로 컴포넌트가 **리렌더링**됩니다.
4.  리렌더링되면서 `handleLoad()`가 또다시 호출됩니다. (1번으로 돌아감)

이 과정이 무한히 반복되면서 네트워크 요청을 계속 보내는 **무한 루프**에 빠지게 됩니다.

### `useEffect`로 무한 루프 탈출하기

`useEffect`는 이 문제를 해결하기 위해 탄생했습니다. **"이 작업은 딱 한 번만, 첫 렌더링 직후에만 실행해 줘"** 라고 React에게 알려줄 수 있죠.

```jsx
import { useState, useEffect } from 'react';

function App() {
  const [items, setItems] = useState([]);

  const handleLoad = async () => {
    const { reviews } = await getReviews();
    setItems(reviews);
  };

  useEffect(() => {
    handleLoad();
  }, []); // 👈 의존성 배열을 비워두면 '첫 렌더링 직후에 한 번만' 이라는 의미

  // ...
}
```

의존성 배열(`[]`)을 비워두면, `useEffect`는 **컴포넌트가 처음 렌더링될 때 딱 한 번만** 콜백 함수를 실행하고 그 이후에는 절대 실행하지 않아 무한 루프를 막을 수 있습니다.
