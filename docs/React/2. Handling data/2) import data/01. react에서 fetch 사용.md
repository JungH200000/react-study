## React에서 서버 데이터 가져오기 (fetch, async/await)

지금까지는 `mock.json`이라는 가짜 데이터를 사용했지만, 이제는 실제 서버에 데이터를 요청하고 응답받아 화면에 렌더링하는 방법을 알아보겠습니다. 이 과정의 주인공은 바로 **비동기(Asynchronous) 처리**입니다.

### 왜 '비동기'가 필요할까요? ☕

JavaScript는 기본적으로 코드를 한 줄씩 순서대로 처리합니다. 만약 서버에 데이터를 요청하고 응답이 올 때까지 모든 작업을 멈추고 기다린다면 어떻게 될까요? 데이터가 오는 데 3초가 걸린다면, 그 3초 동안 웹사이트는 완전히 멈춰버려 아무런 버튼도 누를 수 없는 '먹통' 상태가 될 겁니다.

이런 문제를 해결하기 위해 **비동기 처리**가 필요합니다. 마치 카페에서 커피를 주문하는 것과 같아요.

1.  **요청(Request)**: 점원에게 커피를 주문합니다. (서버에 데이터 요청)
2.  **기다림(Pending)**: 주문과 동시에 **진동벨(Promise)** 을 받습니다. 커피가 나올 때까지 다른 일을 할 수 있습니다. (JavaScript는 다른 코드들을 계속 실행)
3.  **응답(Response)**: 진동벨이 울리면 커피를 받으러 갑니다. (요청이 성공하면 데이터를 받음)

`fetch`가 바로 이 '주문'을 하는 함수이고, `async/await`는 '진동벨'이 울릴 때까지 깔끔하게 기다리는 방법입니다.

---

### `fetch`, `async`, `await` 파헤치기

#### 1\. `fetch` 함수

`fetch`는 브라우저에 내장된 기능으로, 특정 주소(URL)로 네트워크 요청을 보낼 수 있게 해줍니다. `fetch`를 호출하면, 서버는 즉시 데이터가 아닌 **'언젠가 데이터가 담길 것'이라는 약속(Promise 객체)** 을 먼저 돌려줍니다. (위에서 말한 '진동벨')

#### 2\. `async`와 `await`

`async`와 `await`는 이 '약속(Promise)'을 아주 쉽고 읽기 편하게 다룰 수 있도록 도와주는 최신 문법입니다.

- **`async`**: 함수 앞에 붙여주면, "이 함수 안에서는 비동기 작업이 일어날 것이고, `await`를 사용할 수 있습니다"라고 알려주는 표시입니다.
- **`await`**: '기다리다'라는 뜻처럼, 약속(Promise)이 완료될 때까지 코드의 실행을 잠시 기다립니다. 데이터가 도착하면 그 결과를 반환하고, 다음 코드를 실행하죠. 덕분에 비동기 코드를 마치 동기 코드처럼 순서대로, 깔끔하게 작성할 수 있습니다.

---

### React 프로젝트에 적용하기

이제 이 개념들을 실제 프로젝트에 적용해 보겠습니다.

#### 1\. API 함수 만들기 (`api.js`)

먼저, 네트워크 요청 관련 함수들을 따로 관리하기 위해 `src/api.js` 파일을 생성합니다.

**`src/api.js`**

```javascript
// 'async'를 붙여서 이 함수가 비동기 함수임을 알립니다.
export async function getReviews() {
  // 'await'를 사용해 fetch가 완료될 때까지(데이터를 받아올 때까지) 기다립니다.
  const response = await fetch('https://learn.codeit.kr/api/film-reviews');
  // 'await'를 사용해 받아온 응답(response)을 JSON 형태로 변환할 때까지 기다립니다.
  const body = await response.json();
  // 변환된 데이터를 반환합니다.
  return body;
}
```

#### 2\. `App` 컴포넌트에서 데이터 불러오기

이제 `App.jsx`에서 `mock.json`을 제거하고, '불러오기' 버튼을 눌렀을 때 `getReviews` 함수를 호출하여 실제 네트워크 데이터를 가져오도록 코드를 수정합니다.

**`src/App.jsx`**

```jsx
import { useState } from 'react';
import ReviewList from './components/ReviewList';
import { getReviews } from './api';

function App() {
  const [items, setItems] = useState([]); // 👈 초기값은 빈 배열
  const [order, setOrder] = useState('createdAt');
  const sortedItems = [...items].sort((a, b) => b[order] - a[order]);

  const handleNewestClick = () => setOrder('createdAt');
  const handleBestClick = () => setOrder('rating');

  const handleDelete = (id) => {
    const nextItems = items.filter((item) => item.id !== id);
    setItems(nextItems);
  };

  // '불러오기' 버튼 클릭 시 실행될 비동기 함수
  const handleLoadClick = async () => {
    // getReviews 함수가 완료될 때까지 기다립니다.
    const { reviews } = await getReviews();
    // reviews 프로퍼티만 꺼내서 state에 저장합니다.
    setItems(reviews);
  };

  return (
    <div>
      <div>
        <button onClick={handleNewestClick}>최신순</button>
        <button onClick={handleBestClick}>베스트순</button>
      </div>
      <ReviewList items={sortedItems} onDelete={handleDelete} />
      <button onClick={handleLoadClick}>불러오기</button>
    </div>
  );
}

export default App;
```

이제 `npm run dev`로 실행하면 처음에는 빈 화면이 보이다가, '불러오기' 버튼을 누르면 네트워크에서 가져온 데이터로 리뷰 목록이 멋지게 렌더링되는 것을 확인할 수 있습니다\!
