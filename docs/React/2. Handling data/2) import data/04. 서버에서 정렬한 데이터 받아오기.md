## 서버에서 정렬된 데이터 받아오기 (useEffect, Query)

지금은 데이터를 모두 받아온 뒤 프론트엔드에서 `sort`로 정렬하고 있습니다. 하지만 데이터가 수만 개라면, 불필요한 데이터를 모두 받아오는 것은 비효율적입니다. "서버님, 처음부터 **별점순으로 정렬된 데이터**를 주세요\!"라고 요청하는 것이 훨씬 좋겠죠.

이때 사용하는 것이 바로 **쿼리(Query)** 입니다.

### 쿼리(Query)란 무엇일까요? 🏷️

쿼리는 URL 주소 뒤에 `?`를 붙여서 서버에 추가적인 정보를 전달하는 방법입니다. 마치 커피를 주문할 때 "아메리카노 주세요. **(쿼리 시작 `?`)** 사이즈는 라지로 하고 **(&)** 샷은 하나 추가해주세요." 처럼 요청을 더 구체화하는 '꼬리표'와 같습니다.

`key=value` 형태로 작성하며, 여러 개일 경우 `&`로 연결합니다.

`https://.../film-reviews?order=rating&limit=10`

우리가 사용할 API는 `order`라는 쿼리를 통해 정렬 기준을 받을 수 있습니다.

#### `api.js` 수정하기

`getReviews` 함수가 `order` 값을 받아 쿼리를 만들도록 수정합니다.

```javascript
// src/api.js
export async function getReviews(order = 'createdAt') {
  const query = `order=${order}`;
  const response = await fetch(`/api/film-reviews?${query}`);
  const body = await response.json();
  return body;
}
```

#### `App.jsx` 수정하기

`useEffect`의 의존성 배열에 `order` state를 추가하여, **`order` 값이 바뀔 때마다** API 요청을 다시 보내도록 합니다.

```jsx
// src/App.jsx
import { useState, useEffect } from 'react';
import ReviewList from './components/ReviewList';
import { getReviews } from './api';

function App() {
  const [items, setItems] = useState([]);
  const [order, setOrder] = useState('createdAt');
  const sortedItems = [...items].sort((a, b) => b[order] - a[order]);

  const handleNewestClick = () => setOrder('createdAt');
  const handleBestClick = () => setOrder('rating');

  const handleDelete = (id) => {
    const nextItems = items.filter((item) => item.id !== id);
    setItems(nextItems);
  };

  const handleLoad = async (orderQuery) => {
    const { reviews } = await getReviews(orderQuery);
    setItems(reviews);
  };

  useEffect(() => {
    // order state를 handleLoad 함수에 인자로 전달
    handleLoad(order);
  }, [order]); // 👈 의존성 배열에 order를 추가

  return (
    <div>
      <div>
        <button onClick={handleNewestClick}>최신순</button>
        <button onClick={handleBestClick}>베스트순</button>
      </div>
      <ReviewList items={sortedItems} onDelete={handleDelete} />
    </div>
  );
}

export default App;
```

이제 페이지가 처음 열리면 `order`의 초기값인 `createdAt`으로 데이터를 요청하고, '베스트순' 버튼을 누르면 `order` state가 `rating`으로 변경됩니다. `useEffect`는 이 변화를 감지하고, 새로운 `order` 값으로 `handleLoad` 함수를 다시 호출하여 서버로부터 별점순으로 정렬된 데이터를 받아와 화면을 업데이트합니다.

> **🧐 잠깐, 요청이 두 번 가나요?**
>
> 만약 개발자 도구에서 네트워크 요청이 2번씩 가는 것을 보셨다면, 이는 React의 **`StrictMode`** 때문입니다. `StrictMode`는 개발 모드에서 컴포넌트의 잠재적인 문제를 찾기 위해 일부러 렌더링과 Effect를 두 번 실행합니다.
>
> 이는 의도된 동작이며, **`npm run build`로 프로덕션 빌드를 만들면 이중 호출이 사라지고 정상적으로 한 번만 실행되니** 안심하셔도 됩니다.
