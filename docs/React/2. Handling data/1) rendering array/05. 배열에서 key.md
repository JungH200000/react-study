## React 배열 렌더링의 숨은 주인공, `key` prop

React에서 `map` 메소드를 사용해 배열을 렌더링할 때, 각 요소에 **`key`** prop을 지정하지 않으면 개발자 도구 콘솔에 이런 경고 메시지가 나타납니다.

> `Warning: Each child in a list should have a unique "key" prop.`
> (경고: 목록의 각 자식 요소는 고유한 "key" prop을 가져야 합니다.)

이 경고는 왜 나타나는 것이며, `key`는 도대체 어떤 역할을 하는 걸까요?

### `key`가 없다면 어떤 문제가 생길까?

`key`의 역할을 알아보기 위해, 각 리뷰 아이템에 `<input>` 태그를 추가하고 `key` prop을 잠시 제거해 보겠습니다.

```jsx
// src/components/ReviewList.jsx (key가 없는 경우)
function ReviewList({ items, onDelete }) {
  return (
    <ul>
      {items.map((item) => (
        <li>
          <ReviewListItem item={item} onDelete={onDelete} />
          <input type="text" />
        </li>
      ))}
    </ul>
  );
}
```

이제 두 번째 리뷰 아이템의 `input` 창에 "테스트"라고 입력한 뒤, **첫 번째 리뷰 아이템을 삭제**해 보겠습니다.

**예상**: 두 번째 아이템이 첫 번째 자리에 오면서, "테스트"라는 `input` 값도 그대로 따라올 것이다.
**결과**: "테스트"라는 `input` 값이 엉뚱하게 **새로운 두 번째 아이템의 `input` 창으로 이동**합니다. 기존 `input`의 상태가 유지되지 않는 문제가 발생하죠.

### `key`로 배열의 인덱스(index)를 쓰면 안 되는 이유

혹시 `map` 메소드의 두 번째 인자인 `index`를 `key`로 사용하면 어떨까요?

```jsx
// ⚠️ 좋지 않은 예시입니다.
items.map((item, index) => <li key={index}>...</li>);
```

결론부터 말하면, **배열의 `index`는 `key`로 사용하는 것을 강력하게 권장하지 않습니다.** 위와 같이 `index`를 `key`로 사용하고 똑같이 첫 번째 아이템을 삭제하면, `key`가 없을 때와 동일한 문제가 발생합니다.

`index`는 데이터에 부여된 고유한 값이 아니라, 그저 **렌더링되는 시점의 순서**일 뿐이기 때문입니다. 첫 번째 아이템이 삭제되면, 기존의 두 번째 아이템은 새로운 첫 번째 아이템이 되어 `index`가 `1`에서 `0`으로 바뀝니다. React는 `key`를 기준으로 요소를 식별하는데, `index`를 `key`로 사용하면 데이터와 `key`가 일치하지 않는 상황이 발생하여 효율적으로 변경 사항을 추적할 수 없게 됩니다.

### `key`의 올바른 사용법: 고유한 ID 값

`key`는 **항상 각 데이터를 고유하게 식별할 수 있는 안정적인 값**을 사용해야 합니다. `mock.json`의 `id`처럼, 배열의 순서가 바뀌거나 아이템이 추가/삭제되어도 절대 변하지 않는 값이 가장 이상적입니다.

```jsx
// src/components/ReviewList.jsx (올바른 key 사용)
function ReviewList({ items, onDelete }) {
  return (
    <ul>
      {items.map((item) => (
        <li key={item.id}>
          {/* 👈 데이터의 고유한 id를 key로 지정 */}
          <ReviewListItem item={item} onDelete={onDelete} />
          <input type="text" />
        </li>
      ))}
    </ul>
  );
}
```

이제 `item.id`를 `key`로 지정하고 다시 테스트해 보면, 첫 번째 아이템을 삭제해도 두 번째 아이템의 `input` 값이 온전히 유지되는 것을 볼 수 있습니다.

---

### 왜 이런 현상이 발생할까? 🤔

React가 배열의 변화를 감지하는 방식을 생각해보면 이유를 알 수 있습니다.

`['청아', '지원', '현사']` 라는 배열이 `'지원'`이 사라진 `['청아', '현사']` 로 바뀌었다고 해봅시다.

- **React의 고민**: "어떻게 바뀐 거지? '지원'이 삭제된 건가? 아니면 '현사'가 삭제되고 '지원'이 '현사'로 이름이 바뀐 건가?" 결과만 봐서는 알 수 없습니다.

- **`key`의 역할**: `key`는 각 요소에게 **이름표**를 달아주는 것과 같습니다.

  **변경 전**:

  ```js
  [
    { key: 1, name: '청아' },
    { key: 2, name: '지원' },
    { key: 3, name: '현사' },
  ];
  ```

  **변경 후**:

  ```js
  [
    { key: 1, name: '청아' },
    { key: 3, name: '현사' },
  ];
  ```

이제 React는 이름표를 보고, `key`가 2인 '지원'이 사라졌다는 것을 **명확하고 효율적으로 파악**할 수 있습니다. 덕분에 최소한의 연산으로 화면을 정확하게 업데이트할 수 있는 것이죠.

**결론적으로, `map`을 사용할 때는 반드시 각 데이터를 식별할 수 있는 안정적이고 고유한 값을 `key`로 지정해야 합니다.**
