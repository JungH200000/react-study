## React 코드 리팩토링: 불필요한 State 줄이기

코드를 작성하다 보면 처음에는 미처 발견하지 못했던 개선점이 보이곤 합니다. 이번에는 '주사위 게임' 코드의 **상태(State) 관리 방식을 리팩토링**하여 더 깔끔하고 효율적으로 만들어 보겠습니다.

### 무엇이 문제일까요? (State 중복)

기존의 `App.jsx` 코드를 다시 살펴보겠습니다.

```jsx
// src/App.jsx (리팩토링 전)
function App() {
  const [num, setNum] = useState(1);
  const [sum, setSum] = useState(0);
  const [gameHistory, setGameHistory] = useState([]);
  const [otherNum, setOtherNum] = useState(1);
  const [otherSum, setOtherSum] = useState(0);
  const [otherGameHistory, setOtherGameHistory] = useState([]);
  // ...
}
```

'나'와 '상대'의 상태를 관리하기 위해 총 6개의 `state`를 사용하고 있습니다. 하지만 여기서 **`num`(현재 주사위 숫자)과 `sum`(총점)은 사실 `gameHistory`(기록)에서 파생될 수 있는 값들**입니다.

- **현재 주사위 숫자(`num`)**: `gameHistory` 배열의 **가장 마지막 값**입니다.
- **총점(`sum`)**: `gameHistory` 배열의 **모든 요소를 더한 값**입니다.

이처럼 원본 데이터(Source of Truth)가 있는데, 그로부터 충분히 계산해낼 수 있는 값을 별도의 `state`로 두는 것은 코드를 복잡하게 만드는 원인이 됩니다. 상태가 변경될 때마다 여러 `state`를 동시에 관리해야 하므로 버그가 발생할 가능성도 커지죠.

### State를 하나로 통합하기

React 개발에서는 **'신뢰할 수 있는 단일 출처(Single Source of Truth)'** 원칙을 지키는 것이 매우 중요합니다. 우리 코드에서는 `gameHistory`가 바로 그 원본 데이터에 해당합니다.

이제 과감하게 `num`과 `sum` 관련 `state`를 제거하고, 오직 `history` 데이터만 남겨보겠습니다.

```jsx
// src/App.jsx (리팩토링 후)
function App() {
  const [myHistory, setMyHistory] = useState([]);
  const [otherHistory, setOtherHistory] = useState([]);
  // ...
}
```

`state`가 단순해지니 이벤트 핸들러 함수도 훨씬 간결해집니다. 이제 각 함수는 오직 `history` 배열을 업데이트하는 책임만 가집니다.

```jsx
// src/App.jsx (리팩토링 후)
import { useState } from 'react';
import Board from './Board.jsx';
import Button from './Button.jsx';

function random(n) {
  return Math.floor(Math.random() * n) + 1;
}

function App() {
  const [myHistory, setMyHistory] = useState([]);
  const [otherHistory, setOtherHistory] = useState([]);

  const handleRollClick = () => {
    const nextMyNum = random(6);
    const nextOtherNum = random(6);
    setMyHistory([...myHistory, nextMyNum]);
    setOtherHistory([...otherHistory, nextOtherNum]);
  };

  const handleClearClick = () => {
    setMyHistory([]);
    setOtherHistory([]);
  };

  return (
    <div>
      <div>
        <Button onClick={handleRollClick}>던지기</Button>
        <Button onClick={handleClearClick}>처음부터</Button>
      </div>
      <div>
        <Board name="나" color="blue" gameHistory={myHistory} />
        <Board name="상대" color="red" gameHistory={otherHistory} />
      </div>
    </div>
  );
}

export default App;
```

### 파생된 값 계산하기

이제 `state`가 아닌 `props`로 `gameHistory`만 전달받는 `Board` 컴포넌트를 수정할 차례입니다. `Board` 컴포넌트는 전달받은 `gameHistory`를 기반으로 **렌더링될 때마다** 현재 주사위 숫자(`num`)와 총점(`sum`)을 계산합니다.

```jsx
// src/Board.jsx (리팩토링 후)
import Dice from './Dice.jsx';

function Board({ name, color, gameHistory }) {
  // 현재 주사위 숫자는 기록의 마지막 값. 기록이 없으면 기본값 1을 사용합니다.
  const num = gameHistory[gameHistory.length - 1] || 1;

  // 총점은 기록의 모든 값을 더한 값입니다.
  // reduce 메소드를 사용하면 배열의 모든 요소를 순회하며 누적 계산을 할 수 있습니다.
  const sum = gameHistory.reduce((a, b) => a + b, 0);

  return (
    <div>
      <h2>{name}</h2>
      <Dice color={color} num={num} />
      <h2>총점</h2>
      <p>{sum}</p>
      <h2>기록</h2>
      <p>{gameHistory.join(', ')}</p>
    </div>
  );
}

export default Board;
```

어떤가요? ✨ 이제 `App` 컴포넌트는 핵심 데이터(`history`)의 관리만 책임지고, `Board` 컴포넌트는 전달받은 데이터를 화면에 어떻게 그릴지 계산하는 역할에만 집중하게 되었습니다.

이처럼 불필요한 `state`를 줄이고 파생된 값을 활용하면, **코드가 더 간결해지고 예측 가능하며 유지보수하기 쉬워집니다.**
