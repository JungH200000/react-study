## 컴포넌트 재사용과 상태 관리

이번에는 컴포넌트의 가장 큰 장점인 '**재사용성**'을 활용해 보겠습니다. 🚀

완성될 '주사위 게임'은 '나'와 '상대편'의 영역이 사실상 똑같은 구조를 가집니다. 따라서 이 공통된 구조를 하나의 **`Board` 컴포넌트**로 분리하면, 코드를 재사용하여 상대편 영역을 아주 쉽게 구현할 수 있습니다.

먼저, `src/Board.jsx` 파일을 생성하고 기존 `App` 컴포넌트의 코드를 그대로 옮겨 보겠습니다.

```jsx
// src/App.jsx (수정 전)
import { useState } from 'react';
import Button from './Button.jsx';
import Dice from './Dice.jsx';

function random(n) {
  return Math.floor(Math.random() * n) + 1;
}

function App() {
  const [num, setNum] = useState(1);
  const [sum, setSum] = useState(0);
  const [gameHistory, setGameHistory] = useState([]);

  const handleRollClick = () => {
    const nextNum = random(6);
    setNum(nextNum);
    setSum(sum + nextNum);
    setGameHistory([...gameHistory, nextNum]);
  };

  const handleClearClick = () => {
    setNum(1);
    setSum(0);
    setGameHistory([]);
  };

  return (
    <div>
      <div>
        <Button onClick={handleRollClick}>던지기</Button>
        <Button onClick={handleClearClick}>처음부터</Button>
      </div>
      <div>
        <h2>나</h2>
        <Dice color="red" num={num} />
        <h2>총점</h2>
        <p>{sum}</p>
        <h2>기록</h2>
        <p>{gameHistory.join(', ')}</p>
      </div>
    </div>
  );
}

export default App;
```

`App` 컴포넌트의 코드를 `Board.jsx`에 붙여넣은 뒤, 재사용 가능하도록 몇 가지 수정이 필요합니다. `function App() { ... }`이나 `export default App;` 같은 부분을 `Board`로 변경해야 합니다.

> **💡 IDE/에디터 꿀팁\!**
> VSCode와 같은 에디터에서 변경하고 싶은 단어(예: `App`)를 드래그하고 `F2` 키를 누르면, 해당 파일 내의 모든 동일한 단어를 한 번에 변경할 수 있어 편리합니다.

이제 `Board` 컴포넌트를 **`props`를 통해 이름(`name`)과 주사위 색상(`color`)을 받아 동적으로 보여주도록 수정**하겠습니다.

```jsx
// src/Board.jsx (1차 수정)
import { useState } from 'react';
import Button from './Button.jsx';
import Dice from './Dice.jsx';

// random 함수는 이제 App.jsx에서 관리하므로 여기서는 제거합니다.

function Board({ name, color }) {
  // props로 name과 color를 받습니다.
  const [num, setNum] = useState(1);
  const [sum, setSum] = useState(0);
  const [gameHistory, setGameHistory] = useState([]);

  // 이벤트 핸들러들도 곧 App.jsx로 옮겨갈 예정입니다.
  const handleRollClick = () => {
    const nextNum = Math.floor(Math.random() * 6) + 1; // random 함수 대신 직접 구현
    setNum(nextNum);
    setSum(sum + nextNum);
    setGameHistory([...gameHistory, nextNum]);
  };

  const handleClearClick = () => {
    setNum(1);
    setSum(0);
    setGameHistory([]);
  };

  return (
    <div>
      {/* 버튼들은 곧 부모 컴포넌트로 옮겨갈 예정입니다. */}
      <div>
        <Button onClick={handleRollClick}>던지기</Button>
        <Button onClick={handleClearClick}>처음부터</Button>
      </div>
      <div>
        <h2>{name}</h2>
        <Dice color={color} num={num} /> {/* (O) 올바른 사용법 */}
        <h2>총점</h2>
        <p>{sum}</p>
        <h2>기록</h2>
        <p>{gameHistory.join(', ')}</p>
      </div>
    </div>
  );
}

export default Board;
```

이제 `App` 컴포넌트에서는 새로 만든 `Board` 컴포넌트를 사용하여 '사용자'와 '상대' 영역을 렌더링합니다.

```jsx
// src/App.jsx (1차 수정)
import Board from './Board.jsx';

function App() {
  return (
    <div>
      <Board name="사용자" color="blue" />
      <Board name="상대" color="red" />
    </div>
  );
}

export default App;
```

### 상태 끌어올리기 (Lifting State Up)

현재 구조에서는 각 `Board` 컴포넌트가 자신만의 상태(주사위 숫자, 총점 등)를 독립적으로 관리합니다. 하지만 저희가 만들 최종 목표는 **하나의 '던지기' 버튼으로 두 `Board`가 동시에 동작**하는 것입니다.

이를 위해서는 **각 `Board`가 개별적으로 갖던 상태(State)와 이벤트 핸들러를 부모 컴포넌트인 `App`에서 통합 관리**해야 합니다. 이처럼 **자식 컴포넌트의 상태를 부모로 옮겨 부모가 상태를 제어하도록 하는 디자인 패턴**을 '**상태 끌어올리기(Lifting State Up)**'라고 합니다. 🧱

`Board` 컴포넌트에 있던 `state`와 `Button`, 그리고 이벤트 핸들러 함수들을 모두 `App` 컴포넌트로 옮기겠습니다.

```jsx
// src/App.jsx (최종)
import { useState } from 'react';
import Board from './Board.jsx';
import Button from './Button.jsx';

function random(n) {
  return Math.floor(Math.random() * n) + 1;
}

function App() {
  // 사용자의 상태
  const [myNum, setMyNum] = useState(1);
  const [mySum, setMySum] = useState(0);
  const [myHistory, setMyHistory] = useState([]);

  // 상대의 상태
  const [otherNum, setOtherNum] = useState(1);
  const [otherSum, setOtherSum] = useState(0);
  const [otherHistory, setOtherHistory] = useState([]);

  const handleRollClick = () => {
    const nextMyNum = random(6);
    const nextOtherNum = random(6);

    // 사용자 state 업데이트
    setMyNum(nextMyNum);
    setMySum(mySum + nextMyNum);
    setMyHistory([...myHistory, nextMyNum]);

    // 상대 state 업데이트
    setOtherNum(nextOtherNum);
    setOtherSum(otherSum + nextOtherNum);
    setOtherHistory([...otherHistory, nextOtherNum]);
  };

  const handleClearClick = () => {
    // 사용자 state 초기화
    setMyNum(1);
    setMySum(0);
    setMyHistory([]);

    // 상대 state 초기화
    setOtherNum(1);
    setOtherSum(0);
    setOtherHistory([]);
  };

  return (
    <div>
      <div>
        <Button onClick={handleRollClick}>던지기</Button>
        <Button onClick={handleClearClick}>처음부터</Button>
      </div>
      <div>
        {/* App이 관리하는 state와 기록을 props로 전달합니다. */}
        <Board name="나" color="blue" num={myNum} sum={mySum} gameHistory={myHistory} />
        <Board name="상대" color="red" num={otherNum} sum={otherSum} gameHistory={otherHistory} />
      </div>
    </div>
  );
}

export default App;
```

`App` 컴포넌트가 모든 상태를 관리하게 되었으므로, `Board` 컴포넌트는 이제 상태 없이 **`props`로 전달받은 데이터를 화면에 보여주는 역할**에만 집중하는 순수하고 재사용성 높은 컴포넌트가 되었습니다.

```jsx
// src/Board.jsx (최종)
import Dice from './Dice.jsx';

// 부모로부터 필요한 모든 데이터를 props로 전달받습니다.
function Board({ name, color, num, sum, gameHistory }) {
  return (
    <div>
      <h2>{name}</h2>
      <Dice color={color} num={num} />
      <h2>총점</h2>
      <p>{sum}</p>
      <h2>기록</h2>
      <p>{gameHistory.join(', ')}</p>
    </div>
  );
}

export default Board;
```

이제 **`App` 컴포넌트는 모든 상태와 로직을 관리하는 중앙 관제실**이 되었고, **`Board` 컴포넌트는 전달받은 데이터를 화면에 그리는 역할**만 담당하게 되었습니다. 이로써 버튼 하나로 두 `Board`가 동시에 동작하는 기능이 완벽하게 구현되었습니다\! 🎉
