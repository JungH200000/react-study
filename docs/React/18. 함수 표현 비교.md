네, 세 가지 함수의 형태와 역할을 비교해서 설명해 드릴게요. 비슷해 보이지만 각각의 문법과 사용되는 방식에 중요한 차이가 있습니다.

결론부터 말하면, 세 함수는 '**어떻게 선언되었는가**'와 '**어디에서 사용되는가**'에 따라 구분됩니다.

## 세 가지 함수의 비교

| 구분              | `function hello() {}`          | `const hello = () => {}`           | `(a, b) => a + b`                                |
| :---------------- | :----------------------------- | :--------------------------------- | :----------------------------------------------- |
| **종류**          | 함수 선언문                    | 함수 표현식 (화살표 함수)          | 인라인 콜백 함수 (화살표 함수)                   |
| **이름**          | 있음 (hello)                   | 있음 (hello)                       | **없음 (익명)**                                  |
| **`this` 바인딩** | 호출 방식에 따라 동적으로 결정 | **선언될 때의 상위 스코프**로 고정 | **선언될 때의 상위 스코프**로 고정               |
| **호이스팅**      | **가능 (O)**                   | **불가능 (X)**                     | 해당 없음                                        |
| **주요 용도**     | 일반적인 함수 정의             | 일반적인 함수 정의, 콜백 함수      | 다른 함수의 인자로 전달되는 **일회성 콜백 함수** |

---

### 1\. 함수 선언문 (Function Declaration)

가장 전통적이고 기본적인 함수 선언 방식입니다.

```javascript
function sayHello() {
  return '안녕하세요!';
}

console.log(sayHello()); // "안녕하세요!" 출력
```

- **특징**: `function` 키워드로 시작하며, `sayHello`라는 명확한 이름을 가집니다.

- **호이스팅 (Hoisting) hoisting이란, 코드 실행 전에 함수나 변수 선언을 해당 스코프의 최상단으로 끌어올리는 javascript의 동작 방식을 의미합니다.**

  - **가장 큰 특징은 호이스팅이 가능하다는 것입니다.** 즉, 코드를 작성할 때 함수를 선언한 위치보다 더 위에서 호출해도 문제없이 동작합니다. 자바스크립트 엔진이 실행 전에 함수 선언을 먼저 인식하기 때문이죠.

  <!-- end list -->

  ```javascript
  // 함수 선언보다 위에서 호출해도 정상 작동
  console.log(sayHello()); // "안녕하세요!"

  function sayHello() {
    return '안녕하세요!';
  }
  ```

### 2\. 함수 표현식 (Function Expression)

함수를 변수에 할당하는 방식입니다. 특히 화살표 함수(`=>`) 문법은 모던 자바스크립트에서 매우 널리 쓰입니다.

```javascript
const sayGoodbye = () => {
  return '안녕히 가세요!';
};

console.log(sayGoodbye()); // "안녕히 가세요!" 출력
```

또는

```javascript
const sayGoodbye = () => '안녕히 가세요!';

console.log(sayGoodbye()); // "안녕히 가세요!" 출력
```

- **특징**: `const`나 `let` 같은 변수 선언 키워드로 시작합니다. 함수 자체가 하나의 '값'처럼 취급되어 `sayGoodbye`라는 변수에 저장됩니다.

- **`this` 동작 방식**: 화살표 함수는 자신만의 `this`를 갖지 않습니다. 대신, 함수가 선언된 곳의 `this`를 그대로 물려받아 사용합니다. 이 특징 때문에 React와 같은 라이브러리에서 복잡한 `this` 문제없이 컴포넌트의 상태나 메서드에 접근하기 위해 널리 사용됩니다. (이에 대해서는 "현업에서 널리 쓰인다"는 표현을 사용할 때 기술적인 이유와 공식 문서를 함께 알려달라는 요청에 따라, 나중에 더 자세히 설명해 드릴 수 있습니다.)

- **호이스팅 (Hoisting)**: **불가능합니다.** 변수 선언과 동일한 규칙을 따르기 때문에, 반드시 `sayGoodbye`가 선언된 이후에만 호출할 수 있습니다.

  ```javascript
  // 변수 선언보다 위에서 호출하면 에러 발생
  console.log(sayGoodbye()); // ReferenceError: Cannot access 'sayGoodbye' before initialization

  const sayGoodbye = () => {
    return '안녕히 가세요!';
  };
  ```

### 3\. 인라인 콜백 함수 (Inline Callback Function)

이 함수는 독립적으로 존재하기보다, 다른 함수의 \*\*'인자(Argument)'\*\*로 전달되기 위해 일회성으로 만들어지는 함수입니다.

```javascript
const sum = gameHistory.reduce((a, b) => a + b, 0);
```

- **특징**:
  - **이름이 없습니다 (익명 함수, Anonymous Function).** `reduce`라는 함수가 필요로 할 때 즉석에서 만들어져 사용되고 사라집니다.
  - 보통 `map`, `filter`, `reduce`처럼 배열을 다루는 고차 함수나, 이벤트 리스너의 인자로 자주 사용됩니다.
- **왜 이렇게 쓸까요?**: `sum`을 구하는 로직은 `reduce` 함수 안에서만 필요하고 다른 곳에서는 쓰이지 않습니다. 굳이 `function add(a, b) { return a + b; }` 와 같이 별도의 함수를 선언하고 `gameHistory.reduce(add, 0)` 처럼 사용하는 것보다, 코드가 사용되는 그 자리에 바로 작성하는 것이 훨씬 간결하고 가독성이 좋기 때문입니다.

### 요약

- `function sayHello() {}` (선언문): **"나는 `sayHello`라는 이름을 가진 함수야."** (끌어올리기 가능)
- `const sayGoodbye = () => {}` (표현식): **"나는 함수인데, `sayGoodbye`라는 변수에 담겨 있어."** (끌어올리기 불가능, `this` 고정)
- `(a, b) => a + b` (인라인 콜백): **"나는 이름은 없지만, 지금 이 함수의 인자로 들어가서 잠깐 일하고 사라질 함수야."**
